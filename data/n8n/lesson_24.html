<h1>Управление состоянием</h1>

<p>Управление состоянием критично для сложных мультиагентных систем. Изучим различные подходы к управлению состоянием.</p>

<h2>1. Централизованное состояние</h2>

<p>Одно хранилище для всего состояния:</p>

<pre><code>Agent 1 →
  Database (чтение состояния) →
  Set (обновление) →
  Database (сохранение) →
  
Agent 2 →
  Database (чтение состояния) →
  Set (обновление) →
  Database (сохранение)
</code></pre>

<h3>Структура состояния:</h3>
<pre><code>{
  "session_id": "abc123",
  "state": {
    "step": 2,
    "data": {...},
    "agents": {
      "agent1": {"status": "completed"},
      "agent2": {"status": "in_progress"}
    }
  }
}
</code></pre>

<h2>2. Распределенное состояние</h2>

<p>Каждый агент хранит свое состояние:</p>

<pre><code>Agent 1 →
  Set (локальное состояние) →
  Database (сохранение состояния агента 1) →
  
Agent 2 →
  Set (локальное состояние) →
  Database (сохранение состояния агента 2)
</code></pre>

<h2>3. Состояние в переменных workflow</h2>

<p>Использование переменных n8n для состояния:</p>

<pre><code>Set (инициализация переменных) →
  Agent →
  Set (обновление переменных) →
  Agent (использование переменных)
</code></pre>

<h2>4. Состояние через контекст</h2>

<p>Передача состояния через контекст между агентами:</p>

<pre><code>Agent 1 →
  Set (добавление в контекст) →
  Agent 2 (с контекстом) →
  Set (обновление контекста) →
  Agent 3 (с обновленным контекстом)
</code></pre>

<h2>5. Версионирование состояния</h2>

<p>Сохранение версий состояния для отката:</p>

<pre><code>Database (чтение состояния) →
  Set (создание версии) →
  Database (сохранение версии) →
  Agent (изменение состояния) →
  Database (сохранение нового состояния)
</code></pre>

<h2>6. Синхронизация состояния</h2>

<p>Синхронизация между несколькими экземплярами:</p>

<pre><code>Agent →
  Database (блокировка состояния) →
  Database (чтение) →
  Set (обновление) →
  Database (сохранение) →
  Database (разблокировка)
</code></pre>

<h2>7. Состояние с TTL</h2>

<p>Автоматическое истечение состояния:</p>

<pre><code>Schedule Trigger →
  Database (чтение всех состояний) →
  Code (проверка TTL) →
  Database (удаление истекших)
</code></pre>

<h2>8. Best Practices</h2>

<ul>
    <li>Используйте централизованное состояние для координации</li>
    <li>Храните состояние в базе данных для надежности</li>
    <li>Версионируйте состояние для отката</li>
    <li>Синхронизируйте при конкурентном доступе</li>
    <li>Очищайте устаревшее состояние</li>
    <li>Документируйте структуру состояния</li>
</ul>

<p>В следующем уроке мы изучим обработку больших объемов данных.</p>


