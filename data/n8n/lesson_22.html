<h1>Оптимизация производительности</h1>

<p>Оптимизация производительности критична для эффективной работы мультиагентных систем. Изучим техники оптимизации.</p>

<h2>1. Параллелизация независимых агентов</h2>

<p>Запускайте независимые агенты параллельно:</p>

<pre><code>Input → Split →
  ├─ Agent 1
  ├─ Agent 2
  └─ Agent 3
→ Merge
</code></pre>

<p><strong>Вместо:</strong></p>
<pre><code>Input → Agent 1 → Agent 2 → Agent 3
</code></pre>

<h2>2. Кэширование результатов</h2>

<pre><code>Input →
  Code (хеш входных данных) →
  Code (проверка кэша) →
  IF (есть в кэше?) →
    ├─ True → Set (из кэша) [быстро]
    └─ False → Agent → Code (сохранение в кэш)
</code></pre>

<h3>Кэширование:</h3>
<pre><code>const crypto = require('crypto');
const input = JSON.stringify($input.first().json);
const hash = crypto.createHash('md5').update(input).digest('hex');

// Проверка кэша (в реальности - из базы данных)
const cached = getFromCache(hash);

if (cached) {
  return [{
    json: {
      cached: true,
      result: cached
    }
  }];
}

return [{
  json: {
    cached: false,
    hash: hash
  }
}];
</code></pre>

<h2>3. Батчинг запросов</h2>

<p>Группируйте запросы для обработки батчами:</p>

<pre><code>Input →
  Split In Batches (размер: 10) →
  Agent (обработка батча) →
  Merge
</code></pre>

<h2>4. Оптимизация промптов</h2>

<p>Сокращайте промпты без потери качества:</p>

<ul>
    <li>Удаляйте избыточные инструкции</li>
    <li>Используйте краткие формулировки</li>
    <li>Ограничивайте контекст</li>
</ul>

<h3>До оптимизации:</h3>
<pre><code>Ты опытный аналитик данных с многолетним опытом работы в различных отраслях. 
Твоя задача заключается в том, чтобы тщательно проанализировать предоставленные данные...
</code></pre>

<h3>После оптимизации:</h3>
<pre><code>Аналитик данных. Проанализируй данные и предоставь выводы.
</code></pre>

<h2>5. Ограничение контекста</h2>

<p>Ограничивайте размер истории диалога:</p>

<pre><code>Code (обрезка истории) →
  Set (оптимизированная история) →
  Agent
</code></pre>

<h3>Обрезка:</h3>
<pre><code>const history = $input.first().json.history || [];
const maxMessages = 5; // Оставляем последние 5 сообщений

return [{
  json: {
    history: history.slice(-maxMessages)
  }
}];
</code></pre>

<h2>6. Использование правильной модели</h2>

<p>Выбирайте модель в зависимости от задачи:</p>

<ul>
    <li><strong>deepseek-chat</strong> — для общих задач</li>
    <li><strong>deepseek-coder</strong> — для работы с кодом (может быть быстрее для специфичных задач)</li>
</ul>

<h2>7. Настройка параметров LLM</h2>

<p>Оптимизируйте параметры запросов:</p>

<pre><code>{
  "temperature": 0.3,  // Меньше для более детерминированных ответов
  "max_tokens": 1000,  // Только необходимое количество
  "top_p": 0.9
}
</code></pre>

<h2>8. Асинхронная обработка</h2>

<p>Используйте асинхронные вызовы где возможно:</p>

<pre><code>Input →
  Split →
    ├─ Agent 1 (async)
    ├─ Agent 2 (async)
    └─ Agent 3 (async)
  → Merge (ожидание всех)
</code></pre>

<h2>9. Оптимизация базы данных</h2>

<p>Для работы с базой данных:</p>

<ul>
    <li>Используйте индексы</li>
    <li>Ограничивайте выборки</li>
    <li>Используйте батчинг для записи</li>
    <li>Кэшируйте частые запросы</li>
</ul>

<h2>10. Мониторинг производительности</h2>

<pre><code>Set (start_time) →
  Agent →
  Set (metrics) →
  Code (анализ производительности) →
  IF (медленно?) →
    ├─ True → Code (оптимизация) →
    └─ False → Continue
</code></pre>

<h2>11. Ленивая загрузка</h2>

<p>Загружайте данные только когда необходимо:</p>

<pre><code>Agent →
  IF (нужны дополнительные данные?) →
    ├─ True → Database (загрузка) →
    └─ False → Continue
</code></pre>

<h2>12. Оптимизация сети</h2>

<ul>
    <li>Используйте connection pooling</li>
    <li>Минимизируйте количество запросов</li>
    <li>Используйте компрессию где возможно</li>
    <li>Кэшируйте DNS запросы</li>
</ul>

<h2>13. Профилирование</h2>

<p>Определите узкие места:</p>

<pre><code>Set (profile_start) →
  Agent 1 →
  Set (profile_agent1) →
  Agent 2 →
  Set (profile_agent2) →
  Code (анализ профиля) →
  Set (узкие места)
</code></pre>

<h2>14. Оптимизация памяти</h2>

<ul>
    <li>Очищайте неиспользуемые данные</li>
    <li>Ограничивайте размер буферов</li>
    <li>Используйте стриминг для больших данных</li>
</ul>

<h2>15. Best Practices</h2>

<ul>
    <li>Параллелизуйте независимые операции</li>
    <li>Используйте кэширование агрессивно</li>
    <li>Оптимизируйте промпты</li>
    <li>Ограничивайте контекст</li>
    <li>Мониторьте производительность</li>
    <li>Профилируйте узкие места</li>
    <li>Используйте правильные модели</li>
    <li>Настраивайте параметры LLM</li>
</ul>

<h2>16. Метрики производительности</h2>

<ul>
    <li><strong>Время выполнения</strong> — общее время workflow</li>
    <li><strong>Время на агента</strong> — время выполнения каждого агента</li>
    <li><strong>Использование токенов</strong> — количество использованных токенов</li>
    <li><strong>Стоимость</strong> — оценка стоимости выполнения</li>
    <li><strong>Пропускная способность</strong> — количество задач в единицу времени</li>
</ul>

<h2>17. Пример оптимизации</h2>

<p><strong>До:</strong></p>
<pre><code>Agent 1 (5 сек) → Agent 2 (3 сек) → Agent 3 (4 сек) = 12 секунд
</code></pre>

<p><strong>После:</strong></p>
<pre><code>Split →
  ├─ Agent 1 (5 сек)
  ├─ Agent 2 (3 сек)
  └─ Agent 3 (4 сек)
→ Merge = 5 секунд (максимум из параллельных)
</code></pre>

<p>В следующем разделе мы изучим продвинутые техники.</p>

